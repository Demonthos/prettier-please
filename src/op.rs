/*
impl ToTokens for BinOp {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            BinOp::Add(t) => t.to_tokens(tokens),
            BinOp::Sub(t) => t.to_tokens(tokens),
            BinOp::Mul(t) => t.to_tokens(tokens),
            BinOp::Div(t) => t.to_tokens(tokens),
            BinOp::Rem(t) => t.to_tokens(tokens),
            BinOp::And(t) => t.to_tokens(tokens),
            BinOp::Or(t) => t.to_tokens(tokens),
            BinOp::BitXor(t) => t.to_tokens(tokens),
            BinOp::BitAnd(t) => t.to_tokens(tokens),
            BinOp::BitOr(t) => t.to_tokens(tokens),
            BinOp::Shl(t) => t.to_tokens(tokens),
            BinOp::Shr(t) => t.to_tokens(tokens),
            BinOp::Eq(t) => t.to_tokens(tokens),
            BinOp::Lt(t) => t.to_tokens(tokens),
            BinOp::Le(t) => t.to_tokens(tokens),
            BinOp::Ne(t) => t.to_tokens(tokens),
            BinOp::Ge(t) => t.to_tokens(tokens),
            BinOp::Gt(t) => t.to_tokens(tokens),
            BinOp::AddEq(t) => t.to_tokens(tokens),
            BinOp::SubEq(t) => t.to_tokens(tokens),
            BinOp::MulEq(t) => t.to_tokens(tokens),
            BinOp::DivEq(t) => t.to_tokens(tokens),
            BinOp::RemEq(t) => t.to_tokens(tokens),
            BinOp::BitXorEq(t) => t.to_tokens(tokens),
            BinOp::BitAndEq(t) => t.to_tokens(tokens),
            BinOp::BitOrEq(t) => t.to_tokens(tokens),
            BinOp::ShlEq(t) => t.to_tokens(tokens),
            BinOp::ShrEq(t) => t.to_tokens(tokens),
        }
    }
}

impl ToTokens for UnOp {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            UnOp::Deref(t) => t.to_tokens(tokens),
            UnOp::Not(t) => t.to_tokens(tokens),
            UnOp::Neg(t) => t.to_tokens(tokens),
        }
    }
}
*/
